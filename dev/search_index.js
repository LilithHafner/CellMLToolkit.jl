var documenterSearchIndex = {"docs":
[{"location":"#CellMLToolkit.jl","page":"Home","title":"CellMLToolkit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CellMLToolkit.jl is a Julia library that connects CellML models to the Scientific Julia ecosystem. CellMLToolkit.jl acts as a bridge between CellML and ModelingToolkit.jl. It imports a CellML model (in XML) and emits a ModelingToolkit.jl intermediate representation (IR), which can then enter the SciML ecosystem.","category":"page"},{"location":"#CellML","page":"Home","title":"CellML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CellML is an XML-based open-standard for the exchange of mathematical models. CellML originally started in 1998 by the Auckland Bioengineering Institute at the University of Auckland and affiliated research groups. Since then, its repository has grown to more than a thousand models. While CellML is not domain-specific, its focus has been on biomedical models. Currently, the active categories in the repository are Calcium Dynamics, Cardiovascular Circulation, Cell Cycle, Cell Migration, Circadian Rhythms, Electrophysiology, Endocrine, Excitation-Contraction Coupling, Gene Regulation, Hepatology, Immunology, Ion Transport, Mechanical Constitutive Laws, Metabolism, Myofilament Mechanics, Neurobiology, pH Regulation, PKPD, Protein Modules, Signal Transduction, and Synthetic Biology. There are many software tools to import, process and run CellML models; however, these tools are not Julia-specific.","category":"page"},{"location":"#SciML","page":"Home","title":"SciML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciML is a collection of Julia libraries for open source scientific computing and machine learning. The centerpiece of SciML is DifferentialEquations.jl, which provides a rich set of ordinary differential equations (ODE) solvers. One major peripheral component of SciML is ModelingToolkit.jl. It is a modeling framework for high-performance symbolic-numeric computation in scientific computing and scientific machine learning. The core of ModelingToolkit.jl is an IR language to code the scientific problems of interest in a high level. Automatic code generation and differentiation allow for the generation of a usable model for the other components of SciML, such as DifferentialEquations.jl.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"  Pkg.add(\"CellMLToolkit\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  using CellMLToolkit, DifferentialEquations, Plots\n\n  ml = CellModel(\"models/lorenz.cellml.xml\")\n\n  tspan = (0, 100.0)\n  prob = ODEProblem(ml, tspan)\n  sol = solve(prob, TRBDF2(), dtmax=0.01)\n  X = map(x -> x[1], sol.u)\n  Z = map(x -> x[3], sol.u)\n  plot(X, Z)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The models directory contains few CellML model examples. Let's start with a simple one, the famous Lorenz equations!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  using CellMLToolkit\n\n  ml = CellModel(\"models/lorenz.cellml.xml\")\n\n  tspan = (0, 100.0)\n  prob = ODEProblem(ml, tspan)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, ml points to a CellModel struct that contains the details of the model and prob is an ODEProblem ready for integration. We can solve and visualize prob as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  using DifferentialEquations, Plots\n\n  sol = solve(prob, TRBDF2(), dtmax=0.01)\n  X = map(x -> x[1], sol.u)\n  Z = map(x -> x[3], sol.u)\n  plot(X, Z)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As expected,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's look at more complicated examples. The next one is the ten Tusscher-Noble-Noble-Panfilov human left ventricular action potential model. This is a mid-range electrophysiology model with 17 states variables and relatively good numerical stability.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  ml = CellModel(\"models/tentusscher_noble_noble_panfilov_2004_a.cellml.xml\")\n  tspan = (0, 5000.0)\n  prob = ODEProblem(ml, tspan)\n  sol = solve(prob, TRBDF2(), dtmax=1.0)\n  V = map(x -> x[1], sol.u)\n  plot(sol.t, V)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also enhance the model by asking ModelingToolkit.jl to generate a Jacobian by passing jac=true to the ODEProblem constructor.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  prob = ODEProblem(ml, tspan; jac=true)  ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The rest remains the same. For the last example, we chose a complex model to stress the ODE solvers: the O'Hara-Rudy left ventricular model. This model has 49 state variables, is very stiff, and is prone to oscillation. The best solver for this model is CVODE_BDF from the Sundial suite.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  ml = CellModel(\"models/ohara_rudy_cipa_v1_2017.cellml.xml\")\n  tspan = (0, 5000.0)\n  prob = ODEProblem(ml, tspan);\n  sol = solve(prob, CVODE_BDF(), dtmax=0.5)\n  V = map(x -> x[1], sol.u)\n  plot(sol.t, V)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Changing-Parameters","page":"Tutorial","title":"Changing Parameters","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Up to this point, we have run the model exactly as provided by CellML. In practice, we need to be able to modify the model parameters (either the initial conditions or the proper parameters). CellMLToolkit has multiple utility functions that help us interrogate and modify the model parameters.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are three list functions: list_states, list_params, and list_initial_conditions. list_states returns a list of the state variables, i.e., the variables present on the left side of an ODE. list_params and list_initial_conditions return arrays of (variable, value) pairs, providing the model parameters and the state variables initial conditions, respectively (corresponding to p and u0 in DifferentialEquations.jl nomenclature).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we are interested in list_params. Let's go back to the ten Tusscher-Noble-Noble-Panfilov model and list its params:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  ml = CellModel(\"models/tentusscher_noble_noble_panfilov_2004_a.cellml.xml\")\n  p = list_params(ml)\n  display(p)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We get a list of the 45 parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"45-element Array{Pair{Operation,Float64},1}:\n stim_start => 10.0\n       g_pK => 0.0146\n      g_bna => 0.00029\n      K_mNa => 40.0\n      b_rel => 0.25\n       g_Ks => 0.062\n      K_pCa => 0.0005\n       g_Kr => 0.096\n       Na_o => 140.0\n       K_up => 0.00025\n            â‹®","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To modify a parameter, we use update_list! function. For example, the following code changes the stimulation period (stim_period) from its default of 1000 ms to 400 ms","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  update_list!(p, \"stim_period\", 400.0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need to pass the new p to ODEProblem constructor as a keyword parameter. The rest of the code remains the same.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"  tspan = (0, 5000.0)\n  prob = ODEProblem(ml, tspan; p=p)\n  sol = solve(prob, TRBDF2(), dtmax=1.0)\n  V = map(x -> x[1], sol.u)\n  plot(sol.t, V)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ODEProblem also accepts a u0 parameter to change the initial conditions (remember u0 = list_initial_conditions(ml)).","category":"page"}]
}
